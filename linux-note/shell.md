# Shell脚本

## 常见Shell

* Bourne Shell: `/usr/bin/sh`或`/bin/sh`
* Bourne Again Shell: `/bin/bash`
* C Shell: `/usr/bin/csh`
* K Shell: `/usr/bin/ksh`
* Shell for Root: `/sbin/sh`

大部分都使用的是BASH, 也就是Bourne Again Shell.


## shell脚本

* Shebang: `#!`在文件第一行开头位置, 后跟shell解释器
    - `#!/bin/bash`
* 扩展名`.sh`, 在linux下扩展名并不影响执行
* 运行shell脚本的2种方法:
    - 作为可执行程序: `./script.sh`
    - 作为解释器参数: `/bin/sh script.sh`
        - 该方式可以不写Shebang


## 注释

* `#`开头的行都是注释
* 没有多行注释方法, 多行注释只能每行都添加`#`


## 变量

* 定义变量
    - 使用变量名直接定义, 不加任何符号
    - 示例: `user`, `your_name`
    - 规则
        - 首个字符必须为字母(a-z, A-Z)
        - 中间不能有空格, 可以使用下划线`_`
        - 不能使用标点符号
        - 不能使用bash里的关键字
* 使用变量
    - 在定义过的变量名前加美元符号`$`, 或`${变量名}`
    - 示例: 
        - `$your_name`, `$user`
        - `${name}`: 有助于系统区分变量名边界
    - 注意: 不能在使用变量时给变量赋值
        - 错误: `$user = "hello"
        - 正确: `user = "hello"`
* 只读变量
    - 只读变量的值不能被改变
    - `readonly 变量名`
    - 示例: `readonly url`
* 删除变量
    - 变量被删除后不能再次使用, `unset`命令不能删除只读变量
    - `unset 变量名`
    - 示例: `unset url`
* 3种变量类型
    - 局部变量: 在脚本或命令中定义, 仅在当前shell实例中有效, 其他shell启动的程序不能访问局部变量
    - 环境变量: 所有程序, 包括shell启动的程序, 都能访问环境变量
    - shell变量: shell程序设置的特殊变量. 其中有一部分是环境变量, 另一部分是局部变量


## 数据类型


### 字符串

* 格式
    - 单引号: `'hello'`
        - 任何字符都会原样输出, 单引号字符串中的变量是无效的
        - 转义后的单引号也不能出现在单引号之内
    - 双引号: `"hello"`
        - 双引号中可以有变量
        - 双引号中可以有转义字符
    - 无引号: `hello`
* 字符串拼接
    - 使用空格连接要拼接的字符串
    - 示例: `echo $user "is " $age " years old"
* 字符串长度
    - `${#字符串变量}`
    - 示例: `echo ${#username}`
* 提取子字符串
    - `${#字符串变量:开始索引:偏移数量}`
    - 示例: `echo ${#username:1:4}`
* 查找子字符串
    - `expr index "$字符串变量" 要查找的字符`
    - 示例: `expr index "$username" a`


### 数组

* 仅支持一维数组, 数组大小没有限制
* 定义数组
    - `数组名=(值1 值2 ... 值n)`: 空格分隔元素
    - 示例: `array=(0 1 2)`
* 读取数组元素
    - `${数组名[下标]}`
        - 下标使用`@`可以获取所有元素
    - 示例: `val=${array[1]}`
* 获取数组长度
    - 与获取字符串长度方法相同


## 命令行参数

* `$参数序号`: 获取执行脚本时的参数
    - 序号0是文件名
    - 序号1开始是参数
* `$#`: 获取参数的个数
* `$*`: 将参数合并为一个单独的字符串显示所有向脚本传递的参数
    - 如传入`1 2 3`三个参数, 则获取到为`"1 2 3"`
* `$@`: 同上, 但不会合并为一个字符串
    - 如传入`1 2 3`三个参数, 则获取到为`"1" "2" "3"`
* `$$`: 当前运行脚本的进程ID
* `$!`: 后台运行的最后一个进程的ID
* `$-`: 显示shell使用的当前选项
* `$?`: 显示最后命令的退出状态. 0表示没有错误, 其他值表示有错误


```shell
# 脚本内容

echo "文件名为: $0"
echo "第一个参数为: $1"

# 执行脚本
./test.sh 1
```


## 基本运算符

> Mac中shell的expr表达式语法是`$((表达式)), 表达式中的乘号`*`不需要使用`\`转义

* 表达式和运算符之间必须要有空格
* 算数运算符
    - `expr 表达式 + 表达式`: `expr $a + $b`
    - `expr 表达式 - 表达式`: `expr $a - $b`
    - `expr 表达式 * 表达式`: `expr $a * $b`
    - `expr 表达式 / 表达式`: `expr $a / $b`
    - `expr 表达式 % 表达式`: `expr $a % $b`
    - `=`: `a=$b`
    - `[ 表达式 == 表达式 ]`: `[ $a == $b ]`
        - 注意, 方括号和表达式之间必须要有空格
    - `[ 表达式 != 表达式 ]`: `[ $a != $b ]`
        - 注意, 方括号和表达式之间必须要有空格
* 关系运算符
    - 只支持数字, 不支持字符串, 除非字符串的值是数字
    - `[ 表达式 -eq 表达式 ]`: 相等
    - `[ 表达式 -ne 表达式 ]`: 不等
    - `[ 表达式 -gt 表达式 ]`: 大于
    - `[ 表达式 -lt 表达式 ]`: 小于
    - `[ 表达式 -ge 表达式 ]`: 大于等于
    - `[ 表达式 -le 表达式 ]`: 小于等于
* 布尔运算符
    - `[ ! 表达式 ]`: 非
    - `[ 表达式 -o 表达式 ]`: 或
    - `[ 表达式 -a 表达式 ]`: 与
* 逻辑运算符
    - `[[ 表达式 && 表达式 ]]`: 逻辑与
    - `[[ 表达式 || 表达式 ]]`: 逻辑或
* 字符串运算符
    - `[ 表达式 = 表达式 ]`: 字符串是否相等
    - `[ 表达式 != 表达式 ]`: 字符串是否不等
    - `[ -z 表达式 ]`: 字符串长度是否为0
    - `[ -n 表达式 ]`: 字符串长度是否不为0
    - `[ 表达式 ]`: 字符串是否不为空
* 文件测试运算符
    - `[ -b 文件 ]`: 检测文件是否是块设备文件
    - `[ -c 文件 ]`: 检测文件是否是字符设备文件
    - `[ -d 文件 ]`: 检测文件是否是目录
    - `[ -f 文件 ]`: 检测文件是否是普通文件(既不是目录, 也不是设备文件)
    - `[ -g 文件 ]`: 检测文件是否设置了SGID位
    - `[ -k 文件 ]`: 检测文件是否设置了sticky bit
    - `[ -p 文件 ]`: 检测文件是否是有名管道
    - `[ -u 文件 ]`: 检测文件是否设置了SUID位
    - `[ -r 文件 ]`: 检测文件是否可读
    - `[ -w 文件 ]`: 检测文件是否可写
    - `[ -x 文件 ]`: 检测文件是否可执行
    - `[ -s 文件 ]`: 检测文件是否为空(文件大小是否为0)
    - `[ -e 文件 ]`: 检测文件(包括目录)是否存在


## echo命令

* 用于字符串输出
* 格式: `echo 字符串`
    - `echo "hello world"`
    - `echo hello world`
    - `echo "\"hello world\""`
    - `echo "$user is not exist"`
    - `echo <反单引号>命令<反单引号>`: 将命令执行结果输出
* 选项
    - `-e`: 开启转义
        - `echo -e "OK \c"`: `\c`不换行
    - `>`: 覆盖内容重定向输出到文件
        - `echo "Hi" > file.txt`
    - `>>`: 追加内容重定向输出到文件
        - `echo "hi" >> file.txt`
    - `<`: 从文件重定向输入到命令



## printf命令

* 用于字符串输出
* 与echo的区别:
    - 模仿c的printf()定义, 比echo移植性好
    - 可以使用格式化字符串
    - 可以控制字符串宽度, 左右对齐
    - 默认不会添加换行符
* 格式: `printf 格式化字符串 [参数列表]`
    - `%s`: 字符串类型
    - `%c`: 字符
    - `%d`: 整数
    - `%f`: 小数
    - `%-数字s`: 
        - `-`表示左对齐, 没有表示右对齐
        - 数字指定字符串宽度, 不足以空格填充, 超过仍会显示出来
* 转义字符
    - `\a`: 警告字符
    - `\b`: 后退
    - `\c`: 不换行
    - `\f`: 换页
    - `\n`: 换行
    - `\r`: 回车
    - `\t`: 水平制表符
    - `\v`: 垂直制表符
    - `\\`: 反斜杠
    - `\ddd`: 八进制值的字符, 仅在格式字符串中有效
    - `\0ddd`: 八进制值的字符


## 流程控制

* shell的流程内容不可为空, 例如else没有语句执行就不要写

### if条件判断

```shell
# 条件控制
if 条件
then
    语句
    语句
fi

# 写成一行
if 条件; then 语句; fi

# if ... else ...
if 条件
then
    语句
else
    语句
fi

# if ... else if ... else
if 条件
then
    语句
elif 条件
then
    语句
elif 条件
then
    语句
else
    语句
fi
```

### for循环

```shell
# for循环
for 变量 in 元素1 元素2 ... 元素n
do
    语句
    语句
done

# 写成一行
for 变量 in 元素1 元素2 ... 元素n; do 语句; 语句; done;

# 示例
for loop in 1 2 3 4 5
do 
    echo "The value is: $loop"
done
```

### while循环

```shell
# while循环
while 条件
do
    语句
    语句
done

# 无限循环
while :
do 
    语句
done

# 无限循环2
while true
do 
    语句
done

# 无限循环3
for (( ; ; ))
```

### until循环

* 循环执行, 知道符合条件时停止

```shell
# until循环
until 条件
do
    语句
    语句
done
```

### case

* 模式右边以`)`右小括号结束
* `;;`结束模式

```shell
# case
case 值 in
模式1)
    语句
    语句
    ;;
模式2)
    语句
    语句
    ;;
esac

# 示例
case $aNum in
1)
    echo "1"
    ;;
2)
    echo "2"
    ;;
esac
```

### 跳出循环

* `break`: 跳出所有循环
* `continue`: 跳出当前循环


## 函数

* 定义格式
* 参数不需要声明, 在函数内直接使用`$序号`获取参数
    - 序号从1开始
    - 从第10个参数开始, 要使用`${序号}`来获取参数
* 调用函数只需要写函数名, 不需要写括号, 参数使用空格分隔, 跟随在函数名后


```shell
# 函数定义格式
函数名() {              # 或function 函数名() {
    语句
    return 数值(0-255)  # 可选
}

# 示例
hasReturn() {
    return 0;
}
hasReturn

# 有参数
function hasParam() {
    echo $1
    echo ${10}
}
hasParam 1 2 3 4 5 6 7 8 9 10
```

## 输入/输出重定向

* `命令 > 文件`: 将命令输出重定向到文件
* `命令 < 文件`: 将文件内容重定向到命令输入
* `命令 >> 文件`: 将命令输出以追加方式重定向到文件
* `命令 n > 文件`: 将文件描述符为n的文件重定向到文件
* `命令 n >> 文件`: 将文件描述符为n的文件以追加的方式重定向到文件
* `命令 n >& m`: 将输出文件m和n合并
* `命令 n <& m`: 将输入文件m和n合并
* `命令 << 标记`: 将开始标记和结束标记之间的内容作为输入
* 文件描述符:
    - `0`: 通常是标准输入
    - `1`: 通常是标准输出
    - `2`: 通常是标准错误输出
* Here Document重定向, 将输入重定向到一个交互式Shell脚本或程序
* `/dev/null`: 如果希望执行某个命令, 但不想在屏幕输出结果, 可以将输出重定向到该文件
    - 该文件是个特殊的文件, 读不到任何内容

```shell
# < >
who > users.log

wc -l < users.log

命令 < 输入文件 > 输出文件

命令 2 >> 文件

# Here Document
命令 << 结束符
    文字
结束符

wc -l << EOF
    你好世界
EOF
```


## 文件包含

* 允许包含外部脚本, 可以将共用代码作为独立文件
* 语法:
    - `. 文件名`
    - `source 文件名`
* 引入后直接使用变量或函数即可

```shell
# 语法
. 文件名
# 或
source 文件名
```
